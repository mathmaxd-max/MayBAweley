---
import type { Book } from '../data/types';
import BookCard from './BookCard.astro';

interface Props {
  books: Book[];
  selectedBookId?: string;
}

const { books, selectedBookId } = Astro.props;
---

<div class="book-selector-container">
  <div class="relative">
    <!-- Navigation buttons -->
    <button
      class="nav-button nav-button-left"
      aria-label="Vorheriges Buch"
      id="nav-button-left"
    >
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
      </svg>
    </button>
    
    <button
      class="nav-button nav-button-right"
      aria-label="Nächstes Buch"
      id="nav-button-right"
    >
      <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
      </svg>
    </button>

    <!-- Scroll indicators (gradient overlays) -->
    <div class="scroll-indicator scroll-indicator-left" id="scroll-indicator-left"></div>
    <div class="scroll-indicator scroll-indicator-right" id="scroll-indicator-right"></div>

    <!-- Scrollable container with padding-top to prevent clipping -->
    <div
      class="book-selector-scroll flex gap-4 overflow-x-auto pb-4 pt-4 scrollbar-hide scroll-smooth"
      id="book-selector"
      role="list"
      aria-label="Bücher auswählen"
      tabindex="0"
    >
      <!-- Spacer for left edge scrolling -->
      <div class="scroll-spacer-left flex-shrink-0" id="scroll-spacer-left"></div>
      {books.map((book) => (
        <div role="listitem" class="flex-shrink-0">
          <BookCard book={book} isActive={book.id === selectedBookId} />
        </div>
      ))}
      <!-- Spacer for right edge scrolling -->
      <div class="scroll-spacer-right flex-shrink-0" id="scroll-spacer-right"></div>
    </div>
  </div>

  <!-- Dot indicators -->
  <div class="book-indicators" id="book-indicators" role="tablist" aria-label="Buchauswahl">
    {books.map((book, index) => (
      <button
        class="indicator-dot"
        data-index={index}
        aria-label={`Zu ${book.title} springen`}
        role="tab"
        aria-selected={book.id === selectedBookId ? 'true' : 'false'}
      ></button>
    ))}
  </div>
</div>

<style>
  .book-selector-container {
    @apply relative;
  }

  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
    -webkit-overflow-scrolling: touch;
  }
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  .book-selector-scroll {
    @apply relative;
    scroll-padding: 1rem;
  }

  .scroll-spacer-left,
  .scroll-spacer-right {
    /* Width will be set dynamically via JavaScript */
    width: 0;
  }

  /* Navigation buttons */
  .nav-button {
    @apply absolute top-1/2 -translate-y-1/2 z-10 
           bg-white/90 hover:bg-white 
           text-primary 
           rounded-full 
           w-11 h-11 md:w-12 md:h-12
           flex items-center justify-center
           shadow-lg hover:shadow-xl
           transition-all duration-200
           focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2
           disabled:opacity-0 disabled:pointer-events-none
           backdrop-blur-sm;
  }

  .nav-button-left {
    @apply left-2 md:left-4;
  }

  .nav-button-right {
    @apply right-2 md:right-4;
  }

  .nav-button:hover {
    @apply scale-110;
  }

  .nav-button:active {
    @apply scale-95;
  }

  /* Scroll indicators (gradient overlays) */
  .scroll-indicator {
    @apply absolute top-0 bottom-4 w-16 md:w-24 z-[5]
           pointer-events-none
           transition-opacity duration-300;
  }

  .scroll-indicator-left {
    @apply left-0 bg-gradient-to-r from-neutral-light to-transparent;
  }

  .scroll-indicator-right {
    @apply right-0 bg-gradient-to-l from-neutral-light to-transparent;
  }

  .scroll-indicator.hidden {
    @apply opacity-0;
  }

  /* Dot indicators */
  .book-indicators {
    @apply flex justify-center items-center gap-2 mt-6 flex-wrap;
  }

  .indicator-dot {
    @apply w-2.5 h-2.5 md:w-3 md:h-3
           rounded-full
           bg-neutral-dark/30
           transition-all duration-200
           hover:bg-primary/50
           focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-neutral-light
           cursor-pointer
           min-w-[44px] min-h-[44px]
           flex items-center justify-center;
  }

  .indicator-dot[aria-selected="true"] {
    @apply bg-primary w-3 h-3 md:w-4 md:h-4;
  }

  .indicator-dot:hover {
    @apply scale-125;
  }
</style>

<script>
  const selector = document.getElementById('book-selector');
  if (!selector) {
    // Early exit if selector not found
  } else {
    const navButtonLeft = document.getElementById('nav-button-left') as HTMLButtonElement;
    const navButtonRight = document.getElementById('nav-button-right') as HTMLButtonElement;
    const scrollIndicatorLeft = document.getElementById('scroll-indicator-left');
    const scrollIndicatorRight = document.getElementById('scroll-indicator-right');
    const indicators = document.querySelectorAll('.indicator-dot');
    
    let selectedIndex = 0;
    const cards = selector.querySelectorAll('.book-card');
    let isScrolling = false;
    const scrollSpacerLeft = document.getElementById('scroll-spacer-left') as HTMLElement;
    const scrollSpacerRight = document.getElementById('scroll-spacer-right') as HTMLElement;

    // Calculate and set spacer widths to allow edge books to be centered
    function updateSpacerWidths() {
      if (cards.length === 0) return;
      
      const containerWidth = selector.clientWidth;
      const firstCard = cards[0] as HTMLElement;
      const cardWidth = firstCard.getBoundingClientRect().width;
      const gap = 16; // gap-4 = 1rem = 16px
      
      // Spacer width allows edge books to be centered: (container / 2) - (card / 2) - gap
      const spacerWidth = Math.max(0, (containerWidth / 2) - (cardWidth / 2) - gap);
      
      if (scrollSpacerLeft) {
        scrollSpacerLeft.style.width = `${spacerWidth}px`;
      }
      if (scrollSpacerRight) {
        scrollSpacerRight.style.width = `${spacerWidth}px`;
      }
    }

    // Debounce function for scroll events
    function debounce(func: Function, wait: number) {
      let timeout: ReturnType<typeof setTimeout>;
      return function executedFunction(...args: any[]) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Update navigation buttons and scroll indicators based on scroll position
    function updateScrollUI() {
      const scrollLeft = selector.scrollLeft;
      const scrollWidth = selector.scrollWidth;
      const clientWidth = selector.clientWidth;
      const maxScroll = scrollWidth - clientWidth;

      // Show/hide left button and indicator
      const showLeft = scrollLeft > 10;
      if (navButtonLeft) {
        navButtonLeft.disabled = !showLeft;
      }
      if (scrollIndicatorLeft) {
        scrollIndicatorLeft.classList.toggle('hidden', !showLeft);
      }

      // Show/hide right button and indicator
      const showRight = scrollLeft < maxScroll - 10;
      if (navButtonRight) {
        navButtonRight.disabled = !showRight;
      }
      if (scrollIndicatorRight) {
        scrollIndicatorRight.classList.toggle('hidden', !showRight);
      }

      // Update dot indicators based on scroll position
      updateDotIndicators();
    }

    // Update dot indicators to show which book is currently in view
    function updateDotIndicators() {
      const scrollLeft = selector.scrollLeft;
      const containerWidth = selector.clientWidth;
      const cardWidth = cards[0]?.getBoundingClientRect().width || 0;
      const gap = 16; // gap-4 = 1rem = 16px
      
      // Calculate which card is most centered
      const centerPoint = scrollLeft + containerWidth / 2;
      let closestIndex = 0;
      let closestDistance = Infinity;

      cards.forEach((card, index) => {
        const cardElement = card as HTMLElement;
        const cardLeft = cardElement.offsetLeft;
        const cardCenter = cardLeft + cardWidth / 2;
        const distance = Math.abs(centerPoint - cardCenter);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = index;
        }
      });

      // Update selected index if it changed
      if (closestIndex !== selectedIndex) {
        selectedIndex = closestIndex;
        updateSelection();
        
        // Dispatch book-selected event when selection changes via scrolling
        const card = cards[selectedIndex] as HTMLElement;
        if (card) {
          const bookId = card.getAttribute('data-book-id');
          if (bookId) {
            window.dispatchEvent(new CustomEvent('book-selected', { detail: { bookId } }));
          }
        }
      }

      // Update dot indicators
      indicators.forEach((dot, index) => {
        const isActive = index === selectedIndex;
        dot.setAttribute('aria-selected', String(isActive));
      });
    }

    // Scroll to specific card
    function scrollToCard(index: number) {
      const card = cards[index] as HTMLElement;
      if (card) {
        isScrolling = true;
        card.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        selectedIndex = index;
        updateSelection();
        
        // Dispatch book-selected event
        const bookId = card.getAttribute('data-book-id');
        if (bookId) {
          window.dispatchEvent(new CustomEvent('book-selected', { detail: { bookId } }));
        }
        
        // Reset scrolling flag after animation
        setTimeout(() => {
          isScrolling = false;
          updateScrollUI();
        }, 500);
      }
    }

    // Scroll by one card width
    function scrollByCard(direction: 'left' | 'right') {
      const cardWidth = cards[0]?.getBoundingClientRect().width || 0;
      const gap = 16;
      const scrollAmount = cardWidth + gap;
      
      selector.scrollBy({
        left: direction === 'left' ? -scrollAmount : scrollAmount,
        behavior: 'smooth'
      });
    }

    // Navigation button handlers
    if (navButtonLeft) {
      navButtonLeft.addEventListener('click', () => {
        if (selectedIndex > 0) {
          scrollToCard(selectedIndex - 1);
        } else {
          scrollByCard('left');
        }
      });
    }

    if (navButtonRight) {
      navButtonRight.addEventListener('click', () => {
        if (selectedIndex < cards.length - 1) {
          scrollToCard(selectedIndex + 1);
        } else {
          scrollByCard('right');
        }
      });
    }

    // Dot indicator click handlers
    indicators.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        scrollToCard(index);
      });
    });

    // Keyboard navigation
    selector.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (selectedIndex > 0) {
          scrollToCard(selectedIndex - 1);
        }
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (selectedIndex < cards.length - 1) {
          scrollToCard(selectedIndex + 1);
        }
      } else if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        const card = cards[selectedIndex] as HTMLElement;
        card.click();
      }
    });

    // Card click handlers - scroll to card like dot indicators
    cards.forEach((card, index) => {
      card.addEventListener('click', () => {
        scrollToCard(index);
        // Event is already dispatched in scrollToCard
      });
    });

    // Update selection visual state
    function updateSelection() {
      cards.forEach((card, index) => {
        const isActive = index === selectedIndex;
        card.setAttribute('aria-pressed', String(isActive));
        if (isActive) {
          card.classList.add('scale-105', 'shadow-xl', 'ring-2', 'ring-primary');
          card.classList.remove('scale-102', 'shadow-md');
        } else {
          card.classList.remove('scale-105', 'shadow-xl', 'ring-2', 'ring-primary');
          card.classList.add('scale-102', 'shadow-md');
        }
      });
    }

    // Scroll event handler (debounced)
    const handleScroll = debounce(() => {
      if (!isScrolling) {
        updateScrollUI();
      }
    }, 100);

    selector.addEventListener('scroll', handleScroll);

    // Initialize spacers and UI (wait for layout to be ready)
    setTimeout(() => {
      updateSpacerWidths();
      updateScrollUI();
    }, 50);
    
    const initialSelected = Array.from(cards).findIndex(card => 
      card.getAttribute('aria-pressed') === 'true'
    );
    if (initialSelected >= 0) {
      selectedIndex = initialSelected;
      updateSelection();
      // Scroll to initial selected card after spacers are set
      setTimeout(() => {
        scrollToCard(initialSelected);
      }, 150);
    } else {
      // Initial UI update even if no initial selection
      setTimeout(() => {
        updateScrollUI();
      }, 50);
    }

    // Update on resize
    window.addEventListener('resize', debounce(() => {
      updateSpacerWidths();
      updateScrollUI();
    }, 250));
  }
</script>
